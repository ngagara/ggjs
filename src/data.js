export const questions = [{
    key: 1,
    question: `          function sayHi() {
            console.log(name)
            console.log(age)
            var name = "John"
            let age = 30
          }
          
          sayHi()`,
    options: {
      a: 'A: John и undefined',
      b: 'B: John и Error',
      c: 'C: Error',
      d: 'D: undefined и Error'
    },
    correctAnswer: 'd',
    explanation: 'В функции мы сначала определяем переменную "name" с помощью ключевого слова "var". Это означает, что "name" поднимается в начало функции. "name" будет иметь значение undefined до тех пор, пока выполнение кода не дойдет до строки, где ей присваивается значение "John". Мы не определили значение "name", когда пытаемся вывести ее в консоль, поэтому получаем undefined. Переменные, объявленные с помощью ключевого слова "let" (и "const"), также поднимаются, но в отличие от переменных, объявленных с помощью ключевого слова "var", не инициализируются, т.е. такие переменные поднимаются в начало своей области видимости без присвоенного им значения. Доступ к ним до инициализации невозможен. Это называется "временной мертвой зоной". Когда мы пытаемся обратиться к переменным до их определения, JavaScript выбрасывает исключение "ReferenceError". '
  },
  {
    key: 2,
    question: `
          for (var i = 0; i < 3; i++) {
            setTimeout(() => console.log(i), 1)
          }
          
          for (let i = 0; i < 3; i++) {
            setTimeout(() => console.log(i), 1)
          }`,
    options: {
      a: 'A: 0 1 2 и 0 1 2',
      b: 'B: 0 1 2 и 3 3 3',
      c: 'C: 3 3 3 и 0 1 2',
      d: 'D: 3 3 3 и 3 3 3'
    },
    correctAnswer: 'c',
    explanation: 'Из-за очереди событий в JavaScript колбэк функции "setTimeout" выполняется после освобождения стека вызовов. Так как переменная "i" в первом цикле определяется с помощью ключевого слова "var", она является глобальной. В цикле мы каждый раз увеличиваем значение "i" на 1, используя оператор "++". К моменту выполнения колбэка "setTimeout" в первом примере значение "i" равняется 3. Во втором цикле переменная "i" определяется с помощью ключевого слова "let". Такие переменные (а также переменные, объявленные с помощью ключевого слова "const") имеют блочную область видимости (блок - это код внутри фигурных скобок ({})). На каждой итерации "i" будет иметь новое значение, и это значение будет замкнуто в области видимости внутри цикла. '
  },
  {
    key: 3,
    question: `
        const shape = {
            radius: 10,
            diameter() {
              return this.radius * 2
            },
            perimeter: () => 2 * Math.PI * this.radius
          }
          
          console.log(shape.diameter())
          console.log(shape.perimeter())`,
    options: {
      a: 'A: 20 и 62.83185307179586',
      b: 'B: 20 и NaN',
      c: 'C: 20 и 63',
      d: 'D: NaN и 63'
    },
    correctAnswer: 'b',
    explanation: 'Обратите внимание, что "diameter" - это обычная функция, а "perimeter" - стрелочная. У стрелочных функций, в отличие от обычных, значение "this" указывает на лексическое окружение. Это значит, что при вызове метода "perimeter" его "this" указывает не на объект "shape", а на внешнюю область видимости (глобальный объект "window"). У этого объекта нет свойства "radius", поэтому возвращается undefined. '
  },

]